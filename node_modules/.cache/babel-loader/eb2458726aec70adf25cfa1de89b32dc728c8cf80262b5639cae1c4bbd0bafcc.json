{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint max-len: 0 */\n\nimport { File } from \"../index\";\nimport { flowAfterParseClassSuper, flowAfterParseVarHead, flowParseExportDeclaration, flowParseExportStar, flowParseIdentifierStatement, flowParseImportSpecifier, flowParseTypeAnnotation, flowParseTypeParameterDeclaration, flowShouldDisallowExportDefaultSpecifier, flowShouldParseExportDeclaration, flowShouldParseExportStar, flowStartParseFunctionParams, flowStartParseImportSpecifiers, flowTryParseExportDefaultExpression, flowTryParseStatement } from \"../plugins/flow\";\nimport { tsAfterParseClassSuper, tsAfterParseVarHead, tsIsDeclarationStart, tsParseExportDeclaration, tsParseExportSpecifier, tsParseIdentifierStatement, tsParseImportEqualsDeclaration, tsParseImportSpecifier, tsParseMaybeDecoratorArguments, tsParseModifiers, tsStartParseFunctionParams, tsTryParseClassMemberWithIsStatic, tsTryParseExport, tsTryParseExportDefaultExpression, tsTryParseStatementContent, tsTryParseTypeAnnotation, tsTryParseTypeParameters } from \"../plugins/typescript\";\nimport { eat, eatTypeToken, IdentifierRole, lookaheadType, lookaheadTypeAndKeyword, match, next, nextTokenStart, nextTokenStartSince, popTypeContext, pushTypeContext } from \"../tokenizer\";\nimport { ContextualKeyword } from \"../tokenizer/keywords\";\nimport { Scope } from \"../tokenizer/state\";\nimport { TokenType as tt } from \"../tokenizer/types\";\nimport { charCodes } from \"../util/charcodes\";\nimport { getNextContextId, input, isFlowEnabled, isTypeScriptEnabled, state } from \"./base\";\nimport { parseCallExpressionArguments, parseExprAtom, parseExpression, parseExprSubscripts, parseFunctionBodyAndFinish, parseIdentifier, parseMaybeAssign, parseMethod, parseObj, parseParenExpression, parsePropertyName } from \"./expression\";\nimport { parseBindingAtom, parseBindingIdentifier, parseBindingList, parseImportedIdentifier } from \"./lval\";\nimport { canInsertSemicolon, eatContextual, expect, expectContextual, hasFollowingLineBreak, hasPrecedingLineBreak, isContextual, isLineTerminator, isLookaheadContextual, semicolon, unexpected } from \"./util\";\nexport function parseTopLevel() {\n  parseBlockBody(tt.eof);\n  state.scopes.push(new Scope(0, state.tokens.length, true));\n  if (state.scopeDepth !== 0) {\n    throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);\n  }\n  return new File(state.tokens, state.scopes);\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\nexport function parseStatement(declaration) {\n  if (isFlowEnabled) {\n    if (flowTryParseStatement()) {\n      return;\n    }\n  }\n  if (match(tt.at)) {\n    parseDecorators();\n  }\n  parseStatementContent(declaration);\n}\nfunction parseStatementContent(declaration) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseStatementContent()) {\n      return;\n    }\n  }\n  const starttype = state.type;\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case tt._break:\n    case tt._continue:\n      parseBreakContinueStatement();\n      return;\n    case tt._debugger:\n      parseDebuggerStatement();\n      return;\n    case tt._do:\n      parseDoStatement();\n      return;\n    case tt._for:\n      parseForStatement();\n      return;\n    case tt._function:\n      if (lookaheadType() === tt.dot) break;\n      if (!declaration) unexpected();\n      parseFunctionStatement();\n      return;\n    case tt._class:\n      if (!declaration) unexpected();\n      parseClass(true);\n      return;\n    case tt._if:\n      parseIfStatement();\n      return;\n    case tt._return:\n      parseReturnStatement();\n      return;\n    case tt._switch:\n      parseSwitchStatement();\n      return;\n    case tt._throw:\n      parseThrowStatement();\n      return;\n    case tt._try:\n      parseTryStatement();\n      return;\n    case tt._let:\n    case tt._const:\n      if (!declaration) unexpected();\n    // NOTE: falls through to _var\n\n    case tt._var:\n      parseVarStatement(starttype !== tt._var);\n      return;\n    case tt._while:\n      parseWhileStatement();\n      return;\n    case tt.braceL:\n      parseBlock();\n      return;\n    case tt.semi:\n      parseEmptyStatement();\n      return;\n    case tt._export:\n    case tt._import:\n      {\n        const nextType = lookaheadType();\n        if (nextType === tt.parenL || nextType === tt.dot) {\n          break;\n        }\n        next();\n        if (starttype === tt._import) {\n          parseImport();\n        } else {\n          parseExport();\n        }\n        return;\n      }\n    case tt.name:\n      if (state.contextualKeyword === ContextualKeyword._async) {\n        const functionStart = state.start;\n        // peek ahead and see if next token is a function\n        const snapshot = state.snapshot();\n        next();\n        if (match(tt._function) && !canInsertSemicolon()) {\n          expect(tt._function);\n          parseFunction(functionStart, true);\n          return;\n        } else {\n          state.restoreFromSnapshot(snapshot);\n        }\n      } else if (state.contextualKeyword === ContextualKeyword._using && !hasFollowingLineBreak() &&\n      // Statements like `using[0]` and `using in foo` aren't actual using\n      // declarations.\n      lookaheadType() === tt.name) {\n        parseVarStatement(true);\n        return;\n      }\n    default:\n      // Do nothing.\n      break;\n  }\n\n  // If the statement does not start with a statement keyword or a\n  // brace, it's an ExpressionStatement or LabeledStatement. We\n  // simply start parsing an expression, and afterwards, if the\n  // next token is a colon and the expression was a simple\n  // Identifier node, we switch to interpreting it as a label.\n  const initialTokensLength = state.tokens.length;\n  parseExpression();\n  let simpleName = null;\n  if (state.tokens.length === initialTokensLength + 1) {\n    const token = state.tokens[state.tokens.length - 1];\n    if (token.type === tt.name) {\n      simpleName = token.contextualKeyword;\n    }\n  }\n  if (simpleName == null) {\n    semicolon();\n    return;\n  }\n  if (eat(tt.colon)) {\n    parseLabeledStatement();\n  } else {\n    // This was an identifier, so we might want to handle flow/typescript-specific cases.\n    parseIdentifierStatement(simpleName);\n  }\n}\nexport function parseDecorators() {\n  while (match(tt.at)) {\n    parseDecorator();\n  }\n}\nfunction parseDecorator() {\n  next();\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  } else {\n    parseIdentifier();\n    while (eat(tt.dot)) {\n      parseIdentifier();\n    }\n    parseMaybeDecoratorArguments();\n  }\n}\nfunction parseMaybeDecoratorArguments() {\n  if (isTypeScriptEnabled) {\n    tsParseMaybeDecoratorArguments();\n  } else {\n    baseParseMaybeDecoratorArguments();\n  }\n}\nexport function baseParseMaybeDecoratorArguments() {\n  if (eat(tt.parenL)) {\n    parseCallExpressionArguments();\n  }\n}\nfunction parseBreakContinueStatement() {\n  next();\n  if (!isLineTerminator()) {\n    parseIdentifier();\n    semicolon();\n  }\n}\nfunction parseDebuggerStatement() {\n  next();\n  semicolon();\n}\nfunction parseDoStatement() {\n  next();\n  parseStatement(false);\n  expect(tt._while);\n  parseParenExpression();\n  eat(tt.semi);\n}\nfunction parseForStatement() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseAmbiguousForStatement();\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\n/**\n * Determine if this token is a `using` declaration (explicit resource\n * management) as part of a loop.\n * https://github.com/tc39/proposal-explicit-resource-management\n */\nfunction isUsingInLoop() {\n  if (!isContextual(ContextualKeyword._using)) {\n    return false;\n  }\n  // This must be `for (using of`, where `using` is the name of the loop\n  // variable.\n  if (isLookaheadContextual(ContextualKeyword._of)) {\n    return false;\n  }\n  return true;\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\nfunction parseAmbiguousForStatement() {\n  next();\n  let forAwait = false;\n  if (isContextual(ContextualKeyword._await)) {\n    forAwait = true;\n    next();\n  }\n  expect(tt.parenL);\n  if (match(tt.semi)) {\n    if (forAwait) {\n      unexpected();\n    }\n    parseFor();\n    return;\n  }\n  if (match(tt._var) || match(tt._let) || match(tt._const) || isUsingInLoop()) {\n    next();\n    parseVar(true, state.type !== tt._var);\n    if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n      parseForIn(forAwait);\n      return;\n    }\n    parseFor();\n    return;\n  }\n  parseExpression(true);\n  if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n    parseForIn(forAwait);\n    return;\n  }\n  if (forAwait) {\n    unexpected();\n  }\n  parseFor();\n}\nfunction parseFunctionStatement() {\n  const functionStart = state.start;\n  next();\n  parseFunction(functionStart, true);\n}\nfunction parseIfStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n  if (eat(tt._else)) {\n    parseStatement(false);\n  }\n}\nfunction parseReturnStatement() {\n  next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (!isLineTerminator()) {\n    parseExpression();\n    semicolon();\n  }\n}\nfunction parseSwitchStatement() {\n  next();\n  parseParenExpression();\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  expect(tt.braceL);\n\n  // Don't bother validation; just go through any sequence of cases, defaults, and statements.\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._case) || match(tt._default)) {\n      const isCase = match(tt._case);\n      next();\n      if (isCase) {\n        parseExpression();\n      }\n      expect(tt.colon);\n    } else {\n      parseStatement(true);\n    }\n  }\n  next(); // Closing brace\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\nfunction parseThrowStatement() {\n  next();\n  parseExpression();\n  semicolon();\n}\nfunction parseCatchClauseParam() {\n  parseBindingAtom(true /* isBlockScope */);\n\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeAnnotation();\n  }\n}\nfunction parseTryStatement() {\n  next();\n  parseBlock();\n  if (match(tt._catch)) {\n    next();\n    let catchBindingStartTokenIndex = null;\n    if (match(tt.parenL)) {\n      state.scopeDepth++;\n      catchBindingStartTokenIndex = state.tokens.length;\n      expect(tt.parenL);\n      parseCatchClauseParam();\n      expect(tt.parenR);\n    }\n    parseBlock();\n    if (catchBindingStartTokenIndex != null) {\n      // We need a special scope for the catch binding which includes the binding itself and the\n      // catch block.\n      const endTokenIndex = state.tokens.length;\n      state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));\n      state.scopeDepth--;\n    }\n  }\n  if (eat(tt._finally)) {\n    parseBlock();\n  }\n}\nexport function parseVarStatement(isBlockScope) {\n  next();\n  parseVar(false, isBlockScope);\n  semicolon();\n}\nfunction parseWhileStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n}\nfunction parseEmptyStatement() {\n  next();\n}\nfunction parseLabeledStatement() {\n  parseStatement(true);\n}\n\n/**\n * Parse a statement starting with an identifier of the given name. Subclasses match on the name\n * to handle statements like \"declare\".\n */\nfunction parseIdentifierStatement(contextualKeyword) {\n  if (isTypeScriptEnabled) {\n    tsParseIdentifierStatement(contextualKeyword);\n  } else if (isFlowEnabled) {\n    flowParseIdentifierStatement(contextualKeyword);\n  } else {\n    semicolon();\n  }\n}\n\n// Parse a semicolon-enclosed block of statements.\nexport function parseBlock(isFunctionScope = false, contextId = 0) {\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  expect(tt.braceL);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  parseBlockBody(tt.braceR);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));\n  state.scopeDepth--;\n}\nexport function parseBlockBody(end) {\n  while (!eat(end) && !state.error) {\n    parseStatement(true);\n  }\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\nfunction parseFor() {\n  expect(tt.semi);\n  if (!match(tt.semi)) {\n    parseExpression();\n  }\n  expect(tt.semi);\n  if (!match(tt.parenR)) {\n    parseExpression();\n  }\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\nfunction parseForIn(forAwait) {\n  if (forAwait) {\n    eatContextual(ContextualKeyword._of);\n  } else {\n    next();\n  }\n  parseExpression();\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a list of variable declarations.\n\nfunction parseVar(isFor, isBlockScope) {\n  while (true) {\n    parseVarHead(isBlockScope);\n    if (eat(tt.eq)) {\n      const eqIndex = state.tokens.length - 1;\n      parseMaybeAssign(isFor);\n      state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n    }\n    if (!eat(tt.comma)) {\n      break;\n    }\n  }\n}\nfunction parseVarHead(isBlockScope) {\n  parseBindingAtom(isBlockScope);\n  if (isTypeScriptEnabled) {\n    tsAfterParseVarHead();\n  } else if (isFlowEnabled) {\n    flowAfterParseVarHead();\n  }\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseFunction(functionStart, isStatement, optionalId = false) {\n  if (match(tt.star)) {\n    next();\n  }\n  if (isStatement && !optionalId && !match(tt.name) && !match(tt._yield)) {\n    unexpected();\n  }\n  let nameScopeStartTokenIndex = null;\n  if (match(tt.name)) {\n    // Expression-style functions should limit their name's scope to the function body, so we make\n    // a new function scope to enforce that.\n    if (!isStatement) {\n      nameScopeStartTokenIndex = state.tokens.length;\n      state.scopeDepth++;\n    }\n    parseBindingIdentifier(false);\n  }\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  parseFunctionParams();\n  parseFunctionBodyAndFinish(functionStart);\n  const endTokenIndex = state.tokens.length;\n  // In addition to the block scope of the function body, we need a separate function-style scope\n  // that includes the params.\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n  if (nameScopeStartTokenIndex !== null) {\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, true));\n    state.scopeDepth--;\n  }\n}\nexport function parseFunctionParams(allowModifiers = false, funcContextId = 0) {\n  if (isTypeScriptEnabled) {\n    tsStartParseFunctionParams();\n  } else if (isFlowEnabled) {\n    flowStartParseFunctionParams();\n  }\n  expect(tt.parenL);\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n  parseBindingList(tt.parenR, false /* isBlockScope */, false /* allowEmpty */, allowModifiers, funcContextId);\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseClass(isStatement, optionalId = false) {\n  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later\n  // code can easily navigate to meaningful points on the class.\n  const contextId = getNextContextId();\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  state.tokens[state.tokens.length - 1].isExpression = !isStatement;\n  // Like with functions, we declare a special \"name scope\" from the start of the name to the end\n  // of the class, but only with expression-style classes, to represent the fact that the name is\n  // available to the body of the class but not an outer declaration.\n  let nameScopeStartTokenIndex = null;\n  if (!isStatement) {\n    nameScopeStartTokenIndex = state.tokens.length;\n    state.scopeDepth++;\n  }\n  parseClassId(isStatement, optionalId);\n  parseClassSuper();\n  const openBraceIndex = state.tokens.length;\n  parseClassBody(contextId);\n  if (state.error) {\n    return;\n  }\n  state.tokens[openBraceIndex].contextId = contextId;\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  if (nameScopeStartTokenIndex !== null) {\n    const endTokenIndex = state.tokens.length;\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, false));\n    state.scopeDepth--;\n  }\n}\nfunction isClassProperty() {\n  return match(tt.eq) || match(tt.semi) || match(tt.braceR) || match(tt.bang) || match(tt.colon);\n}\nfunction isClassMethod() {\n  return match(tt.parenL) || match(tt.lessThan);\n}\nfunction parseClassBody(classContextId) {\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (eat(tt.semi)) {\n      continue;\n    }\n    if (match(tt.at)) {\n      parseDecorator();\n      continue;\n    }\n    const memberStart = state.start;\n    parseClassMember(memberStart, classContextId);\n  }\n}\nfunction parseClassMember(memberStart, classContextId) {\n  if (isTypeScriptEnabled) {\n    tsParseModifiers([ContextualKeyword._declare, ContextualKeyword._public, ContextualKeyword._protected, ContextualKeyword._private, ContextualKeyword._override]);\n  }\n  let isStatic = false;\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._static) {\n    parseIdentifier(); // eats 'static'\n    if (isClassMethod()) {\n      parseClassMethod(memberStart, /* isConstructor */false);\n      return;\n    } else if (isClassProperty()) {\n      parseClassProperty();\n      return;\n    }\n    // otherwise something static\n    state.tokens[state.tokens.length - 1].type = tt._static;\n    isStatic = true;\n    if (match(tt.braceL)) {\n      // This is a static block. Mark the word \"static\" with the class context ID for class element\n      // detection and parse as a regular block.\n      state.tokens[state.tokens.length - 1].contextId = classContextId;\n      parseBlock();\n      return;\n    }\n  }\n  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);\n}\nfunction parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseClassMemberWithIsStatic(isStatic)) {\n      return;\n    }\n  }\n  if (eat(tt.star)) {\n    // a generator\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */false);\n    return;\n  }\n\n  // Get the identifier name so we can tell if it's actually a keyword like \"async\", \"get\", or\n  // \"set\".\n  parseClassPropertyName(classContextId);\n  let isConstructor = false;\n  const token = state.tokens[state.tokens.length - 1];\n  // We allow \"constructor\" as either an identifier or a string.\n  if (token.contextualKeyword === ContextualKeyword._constructor) {\n    isConstructor = true;\n  }\n  parsePostMemberNameModifiers();\n  if (isClassMethod()) {\n    parseClassMethod(memberStart, isConstructor);\n  } else if (isClassProperty()) {\n    parseClassProperty();\n  } else if (token.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {\n    state.tokens[state.tokens.length - 1].type = tt._async;\n    // an async method\n    const isGenerator = match(tt.star);\n    if (isGenerator) {\n      next();\n    }\n\n    // The so-called parsed name would have been \"async\": get the real name.\n    parseClassPropertyName(classContextId);\n    parsePostMemberNameModifiers();\n    parseClassMethod(memberStart, false /* isConstructor */);\n  } else if ((token.contextualKeyword === ContextualKeyword._get || token.contextualKeyword === ContextualKeyword._set) && !(isLineTerminator() && match(tt.star))) {\n    if (token.contextualKeyword === ContextualKeyword._get) {\n      state.tokens[state.tokens.length - 1].type = tt._get;\n    } else {\n      state.tokens[state.tokens.length - 1].type = tt._set;\n    }\n    // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n    // a getter or setter\n    // The so-called parsed name would have been \"get/set\": get the real name.\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */false);\n  } else if (token.contextualKeyword === ContextualKeyword._accessor && !isLineTerminator()) {\n    parseClassPropertyName(classContextId);\n    parseClassProperty();\n  } else if (isLineTerminator()) {\n    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n    parseClassProperty();\n  } else {\n    unexpected();\n  }\n}\nfunction parseClassMethod(functionStart, isConstructor) {\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n  parseMethod(functionStart, isConstructor);\n}\n\n// Return the name of the class property, if it is a simple identifier.\nexport function parseClassPropertyName(classContextId) {\n  parsePropertyName(classContextId);\n}\nexport function parsePostMemberNameModifiers() {\n  if (isTypeScriptEnabled) {\n    const oldIsType = pushTypeContext(0);\n    eat(tt.question);\n    popTypeContext(oldIsType);\n  }\n}\nexport function parseClassProperty() {\n  if (isTypeScriptEnabled) {\n    eatTypeToken(tt.bang);\n    tsTryParseTypeAnnotation();\n  } else if (isFlowEnabled) {\n    if (match(tt.colon)) {\n      flowParseTypeAnnotation();\n    }\n  }\n  if (match(tt.eq)) {\n    const equalsTokenIndex = state.tokens.length;\n    next();\n    parseMaybeAssign();\n    state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;\n  }\n  semicolon();\n}\nfunction parseClassId(isStatement, optionalId = false) {\n  if (isTypeScriptEnabled && (!isStatement || optionalId) && isContextual(ContextualKeyword._implements)) {\n    return;\n  }\n  if (match(tt.name)) {\n    parseBindingIdentifier(true);\n  }\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n}\n\n// Returns true if there was a superclass.\nfunction parseClassSuper() {\n  let hasSuper = false;\n  if (eat(tt._extends)) {\n    parseExprSubscripts();\n    hasSuper = true;\n  } else {\n    hasSuper = false;\n  }\n  if (isTypeScriptEnabled) {\n    tsAfterParseClassSuper(hasSuper);\n  } else if (isFlowEnabled) {\n    flowAfterParseClassSuper(hasSuper);\n  }\n}\n\n// Parses module export declaration.\n\nexport function parseExport() {\n  const exportIndex = state.tokens.length - 1;\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExport()) {\n      return;\n    }\n  }\n  // export * from '...'\n  if (shouldParseExportStar()) {\n    parseExportStar();\n  } else if (isExportDefaultSpecifier()) {\n    // export default from\n    parseIdentifier();\n    if (match(tt.comma) && lookaheadType() === tt.star) {\n      expect(tt.comma);\n      expect(tt.star);\n      expectContextual(ContextualKeyword._as);\n      parseIdentifier();\n    } else {\n      parseExportSpecifiersMaybe();\n    }\n    parseExportFrom();\n  } else if (eat(tt._default)) {\n    // export default ...\n    parseExportDefaultExpression();\n  } else if (shouldParseExportDeclaration()) {\n    parseExportDeclaration();\n  } else {\n    // export { x, y as z } [from '...']\n    parseExportSpecifiers();\n    parseExportFrom();\n  }\n  state.tokens[exportIndex].rhsEndIndex = state.tokens.length;\n}\nfunction parseExportDefaultExpression() {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  if (isFlowEnabled) {\n    if (flowTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  const functionStart = state.start;\n  if (eat(tt._function)) {\n    parseFunction(functionStart, true, true);\n  } else if (isContextual(ContextualKeyword._async) && lookaheadType() === tt._function) {\n    // async function declaration\n    eatContextual(ContextualKeyword._async);\n    eat(tt._function);\n    parseFunction(functionStart, true, true);\n  } else if (match(tt._class)) {\n    parseClass(true, true);\n  } else if (match(tt.at)) {\n    parseDecorators();\n    parseClass(true, true);\n  } else {\n    parseMaybeAssign();\n    semicolon();\n  }\n}\nfunction parseExportDeclaration() {\n  if (isTypeScriptEnabled) {\n    tsParseExportDeclaration();\n  } else if (isFlowEnabled) {\n    flowParseExportDeclaration();\n  } else {\n    parseStatement(true);\n  }\n}\nfunction isExportDefaultSpecifier() {\n  if (isTypeScriptEnabled && tsIsDeclarationStart()) {\n    return false;\n  } else if (isFlowEnabled && flowShouldDisallowExportDefaultSpecifier()) {\n    return false;\n  }\n  if (match(tt.name)) {\n    return state.contextualKeyword !== ContextualKeyword._async;\n  }\n  if (!match(tt._default)) {\n    return false;\n  }\n  const _next = nextTokenStart();\n  const lookahead = lookaheadTypeAndKeyword();\n  const hasFrom = lookahead.type === tt.name && lookahead.contextualKeyword === ContextualKeyword._from;\n  if (lookahead.type === tt.comma) {\n    return true;\n  }\n  // lookahead again when `export default from` is seen\n  if (hasFrom) {\n    const nextAfterFrom = input.charCodeAt(nextTokenStartSince(_next + 4));\n    return nextAfterFrom === charCodes.quotationMark || nextAfterFrom === charCodes.apostrophe;\n  }\n  return false;\n}\nfunction parseExportSpecifiersMaybe() {\n  if (eat(tt.comma)) {\n    parseExportSpecifiers();\n  }\n}\nexport function parseExportFrom() {\n  if (eatContextual(ContextualKeyword._from)) {\n    parseExprAtom();\n    maybeParseImportAssertions();\n  }\n  semicolon();\n}\nfunction shouldParseExportStar() {\n  if (isFlowEnabled) {\n    return flowShouldParseExportStar();\n  } else {\n    return match(tt.star);\n  }\n}\nfunction parseExportStar() {\n  if (isFlowEnabled) {\n    flowParseExportStar();\n  } else {\n    baseParseExportStar();\n  }\n}\nexport function baseParseExportStar() {\n  expect(tt.star);\n  if (isContextual(ContextualKeyword._as)) {\n    parseExportNamespace();\n  } else {\n    parseExportFrom();\n  }\n}\nfunction parseExportNamespace() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt._as;\n  parseIdentifier();\n  parseExportSpecifiersMaybe();\n  parseExportFrom();\n}\nfunction shouldParseExportDeclaration() {\n  return isTypeScriptEnabled && tsIsDeclarationStart() || isFlowEnabled && flowShouldParseExportDeclaration() || state.type === tt._var || state.type === tt._const || state.type === tt._let || state.type === tt._function || state.type === tt._class || isContextual(ContextualKeyword._async) || match(tt.at);\n}\n\n// Parses a comma-separated list of module exports.\nexport function parseExportSpecifiers() {\n  let first = true;\n\n  // export { x, y as z } [from '...']\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n    parseExportSpecifier();\n  }\n}\nfunction parseExportSpecifier() {\n  if (isTypeScriptEnabled) {\n    tsParseExportSpecifier();\n    return;\n  }\n  parseIdentifier();\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n  if (eatContextual(ContextualKeyword._as)) {\n    parseIdentifier();\n  }\n}\n\n/**\n * Starting at the `module` token in an import, determine if it was truly an\n * import reflection token or just looks like one.\n *\n * Returns true for:\n * import module foo from \"foo\";\n * import module from from \"foo\";\n *\n * Returns false for:\n * import module from \"foo\";\n * import module, {bar} from \"foo\";\n */\nfunction isImportReflection() {\n  const snapshot = state.snapshot();\n  expectContextual(ContextualKeyword._module);\n  if (eatContextual(ContextualKeyword._from)) {\n    if (isContextual(ContextualKeyword._from)) {\n      state.restoreFromSnapshot(snapshot);\n      return true;\n    } else {\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (match(tt.comma)) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  } else {\n    state.restoreFromSnapshot(snapshot);\n    return true;\n  }\n}\n\n/**\n * Eat the \"module\" token from the import reflection proposal.\n * https://github.com/tc39/proposal-import-reflection\n */\nfunction parseMaybeImportReflection() {\n  // isImportReflection does snapshot/restore, so only run it if we see the word\n  // \"module\".\n  if (isContextual(ContextualKeyword._module) && isImportReflection()) {\n    next();\n  }\n}\n\n// Parses import declaration.\n\nexport function parseImport() {\n  if (isTypeScriptEnabled && match(tt.name) && lookaheadType() === tt.eq) {\n    tsParseImportEqualsDeclaration();\n    return;\n  }\n  if (isTypeScriptEnabled && isContextual(ContextualKeyword._type)) {\n    const lookahead = lookaheadTypeAndKeyword();\n    if (lookahead.type === tt.name && lookahead.contextualKeyword !== ContextualKeyword._from) {\n      // One of these `import type` cases:\n      // import type T = require('T');\n      // import type A from 'A';\n      expectContextual(ContextualKeyword._type);\n      if (lookaheadType() === tt.eq) {\n        tsParseImportEqualsDeclaration();\n        return;\n      }\n      // If this is an `import type...from` statement, then we already ate the\n      // type token, so proceed to the regular import parser.\n    } else if (lookahead.type === tt.star || lookahead.type === tt.braceL) {\n      // One of these `import type` cases, in which case we can eat the type token\n      // and proceed as normal:\n      // import type * as A from 'A';\n      // import type {a} from 'A';\n      expectContextual(ContextualKeyword._type);\n    }\n    // Otherwise, we are importing the name \"type\".\n  }\n\n  // import '...'\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseMaybeImportReflection();\n    parseImportSpecifiers();\n    expectContextual(ContextualKeyword._from);\n    parseExprAtom();\n  }\n  maybeParseImportAssertions();\n  semicolon();\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction shouldParseDefaultImport() {\n  return match(tt.name);\n}\nfunction parseImportSpecifierLocal() {\n  parseImportedIdentifier();\n}\n\n// Parses a comma-separated list of module imports.\nfunction parseImportSpecifiers() {\n  if (isFlowEnabled) {\n    flowStartParseImportSpecifiers();\n  }\n  let first = true;\n  if (shouldParseDefaultImport()) {\n    // import defaultObj, { x, y as z } from '...'\n    parseImportSpecifierLocal();\n    if (!eat(tt.comma)) return;\n  }\n  if (match(tt.star)) {\n    next();\n    expectContextual(ContextualKeyword._as);\n    parseImportSpecifierLocal();\n    return;\n  }\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      // Detect an attempt to deep destructure\n      if (eat(tt.colon)) {\n        unexpected(\"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\");\n      }\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n    parseImportSpecifier();\n  }\n}\nfunction parseImportSpecifier() {\n  if (isTypeScriptEnabled) {\n    tsParseImportSpecifier();\n    return;\n  }\n  if (isFlowEnabled) {\n    flowParseImportSpecifier();\n    return;\n  }\n  parseImportedIdentifier();\n  if (isContextual(ContextualKeyword._as)) {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportAccess;\n    next();\n    parseImportedIdentifier();\n  }\n}\n\n/**\n * Parse import assertions like `assert {type: \"json\"}`.\n *\n * Import assertions technically have their own syntax, but are always parseable\n * as a plain JS object, so just do that for simplicity.\n */\nfunction maybeParseImportAssertions() {\n  if (isContextual(ContextualKeyword._assert) && !hasPrecedingLineBreak()) {\n    next();\n    parseObj(false, false);\n  }\n}","map":{"version":3,"names":["File","flowAfterParseClassSuper","flowAfterParseVarHead","flowParseExportDeclaration","flowParseExportStar","flowParseIdentifierStatement","flowParseImportSpecifier","flowParseTypeAnnotation","flowParseTypeParameterDeclaration","flowShouldDisallowExportDefaultSpecifier","flowShouldParseExportDeclaration","flowShouldParseExportStar","flowStartParseFunctionParams","flowStartParseImportSpecifiers","flowTryParseExportDefaultExpression","flowTryParseStatement","tsAfterParseClassSuper","tsAfterParseVarHead","tsIsDeclarationStart","tsParseExportDeclaration","tsParseExportSpecifier","tsParseIdentifierStatement","tsParseImportEqualsDeclaration","tsParseImportSpecifier","tsParseMaybeDecoratorArguments","tsParseModifiers","tsStartParseFunctionParams","tsTryParseClassMemberWithIsStatic","tsTryParseExport","tsTryParseExportDefaultExpression","tsTryParseStatementContent","tsTryParseTypeAnnotation","tsTryParseTypeParameters","eat","eatTypeToken","IdentifierRole","lookaheadType","lookaheadTypeAndKeyword","match","next","nextTokenStart","nextTokenStartSince","popTypeContext","pushTypeContext","ContextualKeyword","Scope","TokenType","tt","charCodes","getNextContextId","input","isFlowEnabled","isTypeScriptEnabled","state","parseCallExpressionArguments","parseExprAtom","parseExpression","parseExprSubscripts","parseFunctionBodyAndFinish","parseIdentifier","parseMaybeAssign","parseMethod","parseObj","parseParenExpression","parsePropertyName","parseBindingAtom","parseBindingIdentifier","parseBindingList","parseImportedIdentifier","canInsertSemicolon","eatContextual","expect","expectContextual","hasFollowingLineBreak","hasPrecedingLineBreak","isContextual","isLineTerminator","isLookaheadContextual","semicolon","unexpected","parseTopLevel","parseBlockBody","eof","scopes","push","tokens","length","scopeDepth","Error","parseStatement","declaration","at","parseDecorators","parseStatementContent","starttype","type","_break","_continue","parseBreakContinueStatement","_debugger","parseDebuggerStatement","_do","parseDoStatement","_for","parseForStatement","_function","dot","parseFunctionStatement","_class","parseClass","_if","parseIfStatement","_return","parseReturnStatement","_switch","parseSwitchStatement","_throw","parseThrowStatement","_try","parseTryStatement","_let","_const","_var","parseVarStatement","_while","parseWhileStatement","braceL","parseBlock","semi","parseEmptyStatement","_export","_import","nextType","parenL","parseImport","parseExport","name","contextualKeyword","_async","functionStart","start","snapshot","parseFunction","restoreFromSnapshot","_using","initialTokensLength","simpleName","token","colon","parseLabeledStatement","parseIdentifierStatement","parseDecorator","parenR","parseMaybeDecoratorArguments","baseParseMaybeDecoratorArguments","startTokenIndex","parseAmbiguousForStatement","endTokenIndex","isUsingInLoop","_of","forAwait","_await","parseFor","parseVar","_in","parseForIn","_else","braceR","error","_case","_default","isCase","parseCatchClauseParam","_catch","catchBindingStartTokenIndex","_finally","isBlockScope","isFunctionScope","contextId","end","isFor","parseVarHead","eq","eqIndex","rhsEndIndex","comma","isStatement","optionalId","star","_yield","nameScopeStartTokenIndex","parseFunctionParams","allowModifiers","funcContextId","isExpression","parseClassId","parseClassSuper","openBraceIndex","parseClassBody","isClassProperty","bang","isClassMethod","lessThan","classContextId","memberStart","parseClassMember","_declare","_public","_protected","_private","_override","isStatic","_static","parseClassMethod","parseClassProperty","parseClassMemberWithIsStatic","parseClassPropertyName","isConstructor","_constructor","parsePostMemberNameModifiers","isGenerator","_get","_set","_accessor","oldIsType","question","equalsTokenIndex","_implements","hasSuper","_extends","exportIndex","shouldParseExportStar","parseExportStar","isExportDefaultSpecifier","_as","parseExportSpecifiersMaybe","parseExportFrom","parseExportDefaultExpression","shouldParseExportDeclaration","parseExportDeclaration","parseExportSpecifiers","_next","lookahead","hasFrom","_from","nextAfterFrom","charCodeAt","quotationMark","apostrophe","maybeParseImportAssertions","baseParseExportStar","parseExportNamespace","first","parseExportSpecifier","identifierRole","ExportAccess","isImportReflection","_module","parseMaybeImportReflection","_type","string","parseImportSpecifiers","shouldParseDefaultImport","parseImportSpecifierLocal","parseImportSpecifier","ImportAccess","_assert"],"sources":["/home/esraisik/Desktop/all-e/my-vue/theshow-vue/node_modules/sucrase/dist/esm/parser/traverser/statement.js"],"sourcesContent":["/* eslint max-len: 0 */\n\nimport {File} from \"../index\";\nimport {\n  flowAfterParseClassSuper,\n  flowAfterParseVarHead,\n  flowParseExportDeclaration,\n  flowParseExportStar,\n  flowParseIdentifierStatement,\n  flowParseImportSpecifier,\n  flowParseTypeAnnotation,\n  flowParseTypeParameterDeclaration,\n  flowShouldDisallowExportDefaultSpecifier,\n  flowShouldParseExportDeclaration,\n  flowShouldParseExportStar,\n  flowStartParseFunctionParams,\n  flowStartParseImportSpecifiers,\n  flowTryParseExportDefaultExpression,\n  flowTryParseStatement,\n} from \"../plugins/flow\";\nimport {\n  tsAfterParseClassSuper,\n  tsAfterParseVarHead,\n  tsIsDeclarationStart,\n  tsParseExportDeclaration,\n  tsParseExportSpecifier,\n  tsParseIdentifierStatement,\n  tsParseImportEqualsDeclaration,\n  tsParseImportSpecifier,\n  tsParseMaybeDecoratorArguments,\n  tsParseModifiers,\n  tsStartParseFunctionParams,\n  tsTryParseClassMemberWithIsStatic,\n  tsTryParseExport,\n  tsTryParseExportDefaultExpression,\n  tsTryParseStatementContent,\n  tsTryParseTypeAnnotation,\n  tsTryParseTypeParameters,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  eatTypeToken,\n  IdentifierRole,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  nextTokenStart,\n  nextTokenStartSince,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {Scope} from \"../tokenizer/state\";\nimport { TokenType as tt} from \"../tokenizer/types\";\nimport {charCodes} from \"../util/charcodes\";\nimport {getNextContextId, input, isFlowEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseExprSubscripts,\n  parseFunctionBodyAndFinish,\n  parseIdentifier,\n  parseMaybeAssign,\n  parseMethod,\n  parseObj,\n  parseParenExpression,\n  parsePropertyName,\n} from \"./expression\";\nimport {\n  parseBindingAtom,\n  parseBindingIdentifier,\n  parseBindingList,\n  parseImportedIdentifier,\n} from \"./lval\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  hasFollowingLineBreak,\n  hasPrecedingLineBreak,\n  isContextual,\n  isLineTerminator,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"./util\";\n\nexport function parseTopLevel() {\n  parseBlockBody(tt.eof);\n  state.scopes.push(new Scope(0, state.tokens.length, true));\n  if (state.scopeDepth !== 0) {\n    throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);\n  }\n  return new File(state.tokens, state.scopes);\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\nexport function parseStatement(declaration) {\n  if (isFlowEnabled) {\n    if (flowTryParseStatement()) {\n      return;\n    }\n  }\n  if (match(tt.at)) {\n    parseDecorators();\n  }\n  parseStatementContent(declaration);\n}\n\nfunction parseStatementContent(declaration) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseStatementContent()) {\n      return;\n    }\n  }\n\n  const starttype = state.type;\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case tt._break:\n    case tt._continue:\n      parseBreakContinueStatement();\n      return;\n    case tt._debugger:\n      parseDebuggerStatement();\n      return;\n    case tt._do:\n      parseDoStatement();\n      return;\n    case tt._for:\n      parseForStatement();\n      return;\n    case tt._function:\n      if (lookaheadType() === tt.dot) break;\n      if (!declaration) unexpected();\n      parseFunctionStatement();\n      return;\n\n    case tt._class:\n      if (!declaration) unexpected();\n      parseClass(true);\n      return;\n\n    case tt._if:\n      parseIfStatement();\n      return;\n    case tt._return:\n      parseReturnStatement();\n      return;\n    case tt._switch:\n      parseSwitchStatement();\n      return;\n    case tt._throw:\n      parseThrowStatement();\n      return;\n    case tt._try:\n      parseTryStatement();\n      return;\n\n    case tt._let:\n    case tt._const:\n      if (!declaration) unexpected(); // NOTE: falls through to _var\n\n    case tt._var:\n      parseVarStatement(starttype !== tt._var);\n      return;\n\n    case tt._while:\n      parseWhileStatement();\n      return;\n    case tt.braceL:\n      parseBlock();\n      return;\n    case tt.semi:\n      parseEmptyStatement();\n      return;\n    case tt._export:\n    case tt._import: {\n      const nextType = lookaheadType();\n      if (nextType === tt.parenL || nextType === tt.dot) {\n        break;\n      }\n      next();\n      if (starttype === tt._import) {\n        parseImport();\n      } else {\n        parseExport();\n      }\n      return;\n    }\n    case tt.name:\n      if (state.contextualKeyword === ContextualKeyword._async) {\n        const functionStart = state.start;\n        // peek ahead and see if next token is a function\n        const snapshot = state.snapshot();\n        next();\n        if (match(tt._function) && !canInsertSemicolon()) {\n          expect(tt._function);\n          parseFunction(functionStart, true);\n          return;\n        } else {\n          state.restoreFromSnapshot(snapshot);\n        }\n      } else if (\n        state.contextualKeyword === ContextualKeyword._using &&\n        !hasFollowingLineBreak() &&\n        // Statements like `using[0]` and `using in foo` aren't actual using\n        // declarations.\n        lookaheadType() === tt.name\n      ) {\n        parseVarStatement(true);\n        return;\n      }\n    default:\n      // Do nothing.\n      break;\n  }\n\n  // If the statement does not start with a statement keyword or a\n  // brace, it's an ExpressionStatement or LabeledStatement. We\n  // simply start parsing an expression, and afterwards, if the\n  // next token is a colon and the expression was a simple\n  // Identifier node, we switch to interpreting it as a label.\n  const initialTokensLength = state.tokens.length;\n  parseExpression();\n  let simpleName = null;\n  if (state.tokens.length === initialTokensLength + 1) {\n    const token = state.tokens[state.tokens.length - 1];\n    if (token.type === tt.name) {\n      simpleName = token.contextualKeyword;\n    }\n  }\n  if (simpleName == null) {\n    semicolon();\n    return;\n  }\n  if (eat(tt.colon)) {\n    parseLabeledStatement();\n  } else {\n    // This was an identifier, so we might want to handle flow/typescript-specific cases.\n    parseIdentifierStatement(simpleName);\n  }\n}\n\nexport function parseDecorators() {\n  while (match(tt.at)) {\n    parseDecorator();\n  }\n}\n\nfunction parseDecorator() {\n  next();\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  } else {\n    parseIdentifier();\n    while (eat(tt.dot)) {\n      parseIdentifier();\n    }\n    parseMaybeDecoratorArguments();\n  }\n}\n\nfunction parseMaybeDecoratorArguments() {\n  if (isTypeScriptEnabled) {\n    tsParseMaybeDecoratorArguments();\n  } else {\n    baseParseMaybeDecoratorArguments();\n  }\n}\n\nexport function baseParseMaybeDecoratorArguments() {\n  if (eat(tt.parenL)) {\n    parseCallExpressionArguments();\n  }\n}\n\nfunction parseBreakContinueStatement() {\n  next();\n  if (!isLineTerminator()) {\n    parseIdentifier();\n    semicolon();\n  }\n}\n\nfunction parseDebuggerStatement() {\n  next();\n  semicolon();\n}\n\nfunction parseDoStatement() {\n  next();\n  parseStatement(false);\n  expect(tt._while);\n  parseParenExpression();\n  eat(tt.semi);\n}\n\nfunction parseForStatement() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseAmbiguousForStatement();\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\n/**\n * Determine if this token is a `using` declaration (explicit resource\n * management) as part of a loop.\n * https://github.com/tc39/proposal-explicit-resource-management\n */\nfunction isUsingInLoop() {\n  if (!isContextual(ContextualKeyword._using)) {\n    return false;\n  }\n  // This must be `for (using of`, where `using` is the name of the loop\n  // variable.\n  if (isLookaheadContextual(ContextualKeyword._of)) {\n    return false;\n  }\n  return true;\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\nfunction parseAmbiguousForStatement() {\n  next();\n\n  let forAwait = false;\n  if (isContextual(ContextualKeyword._await)) {\n    forAwait = true;\n    next();\n  }\n  expect(tt.parenL);\n\n  if (match(tt.semi)) {\n    if (forAwait) {\n      unexpected();\n    }\n    parseFor();\n    return;\n  }\n\n  if (match(tt._var) || match(tt._let) || match(tt._const) || isUsingInLoop()) {\n    next();\n    parseVar(true, state.type !== tt._var);\n    if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n      parseForIn(forAwait);\n      return;\n    }\n    parseFor();\n    return;\n  }\n\n  parseExpression(true);\n  if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n    parseForIn(forAwait);\n    return;\n  }\n  if (forAwait) {\n    unexpected();\n  }\n  parseFor();\n}\n\nfunction parseFunctionStatement() {\n  const functionStart = state.start;\n  next();\n  parseFunction(functionStart, true);\n}\n\nfunction parseIfStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n  if (eat(tt._else)) {\n    parseStatement(false);\n  }\n}\n\nfunction parseReturnStatement() {\n  next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (!isLineTerminator()) {\n    parseExpression();\n    semicolon();\n  }\n}\n\nfunction parseSwitchStatement() {\n  next();\n  parseParenExpression();\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  expect(tt.braceL);\n\n  // Don't bother validation; just go through any sequence of cases, defaults, and statements.\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._case) || match(tt._default)) {\n      const isCase = match(tt._case);\n      next();\n      if (isCase) {\n        parseExpression();\n      }\n      expect(tt.colon);\n    } else {\n      parseStatement(true);\n    }\n  }\n  next(); // Closing brace\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\nfunction parseThrowStatement() {\n  next();\n  parseExpression();\n  semicolon();\n}\n\nfunction parseCatchClauseParam() {\n  parseBindingAtom(true /* isBlockScope */);\n\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeAnnotation();\n  }\n}\n\nfunction parseTryStatement() {\n  next();\n\n  parseBlock();\n\n  if (match(tt._catch)) {\n    next();\n    let catchBindingStartTokenIndex = null;\n    if (match(tt.parenL)) {\n      state.scopeDepth++;\n      catchBindingStartTokenIndex = state.tokens.length;\n      expect(tt.parenL);\n      parseCatchClauseParam();\n      expect(tt.parenR);\n    }\n    parseBlock();\n    if (catchBindingStartTokenIndex != null) {\n      // We need a special scope for the catch binding which includes the binding itself and the\n      // catch block.\n      const endTokenIndex = state.tokens.length;\n      state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));\n      state.scopeDepth--;\n    }\n  }\n  if (eat(tt._finally)) {\n    parseBlock();\n  }\n}\n\nexport function parseVarStatement(isBlockScope) {\n  next();\n  parseVar(false, isBlockScope);\n  semicolon();\n}\n\nfunction parseWhileStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n}\n\nfunction parseEmptyStatement() {\n  next();\n}\n\nfunction parseLabeledStatement() {\n  parseStatement(true);\n}\n\n/**\n * Parse a statement starting with an identifier of the given name. Subclasses match on the name\n * to handle statements like \"declare\".\n */\nfunction parseIdentifierStatement(contextualKeyword) {\n  if (isTypeScriptEnabled) {\n    tsParseIdentifierStatement(contextualKeyword);\n  } else if (isFlowEnabled) {\n    flowParseIdentifierStatement(contextualKeyword);\n  } else {\n    semicolon();\n  }\n}\n\n// Parse a semicolon-enclosed block of statements.\nexport function parseBlock(isFunctionScope = false, contextId = 0) {\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  expect(tt.braceL);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  parseBlockBody(tt.braceR);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));\n  state.scopeDepth--;\n}\n\nexport function parseBlockBody(end) {\n  while (!eat(end) && !state.error) {\n    parseStatement(true);\n  }\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\nfunction parseFor() {\n  expect(tt.semi);\n  if (!match(tt.semi)) {\n    parseExpression();\n  }\n  expect(tt.semi);\n  if (!match(tt.parenR)) {\n    parseExpression();\n  }\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\nfunction parseForIn(forAwait) {\n  if (forAwait) {\n    eatContextual(ContextualKeyword._of);\n  } else {\n    next();\n  }\n  parseExpression();\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a list of variable declarations.\n\nfunction parseVar(isFor, isBlockScope) {\n  while (true) {\n    parseVarHead(isBlockScope);\n    if (eat(tt.eq)) {\n      const eqIndex = state.tokens.length - 1;\n      parseMaybeAssign(isFor);\n      state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n    }\n    if (!eat(tt.comma)) {\n      break;\n    }\n  }\n}\n\nfunction parseVarHead(isBlockScope) {\n  parseBindingAtom(isBlockScope);\n  if (isTypeScriptEnabled) {\n    tsAfterParseVarHead();\n  } else if (isFlowEnabled) {\n    flowAfterParseVarHead();\n  }\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseFunction(\n  functionStart,\n  isStatement,\n  optionalId = false,\n) {\n  if (match(tt.star)) {\n    next();\n  }\n\n  if (isStatement && !optionalId && !match(tt.name) && !match(tt._yield)) {\n    unexpected();\n  }\n\n  let nameScopeStartTokenIndex = null;\n\n  if (match(tt.name)) {\n    // Expression-style functions should limit their name's scope to the function body, so we make\n    // a new function scope to enforce that.\n    if (!isStatement) {\n      nameScopeStartTokenIndex = state.tokens.length;\n      state.scopeDepth++;\n    }\n    parseBindingIdentifier(false);\n  }\n\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  parseFunctionParams();\n  parseFunctionBodyAndFinish(functionStart);\n  const endTokenIndex = state.tokens.length;\n  // In addition to the block scope of the function body, we need a separate function-style scope\n  // that includes the params.\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n  if (nameScopeStartTokenIndex !== null) {\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, true));\n    state.scopeDepth--;\n  }\n}\n\nexport function parseFunctionParams(\n  allowModifiers = false,\n  funcContextId = 0,\n) {\n  if (isTypeScriptEnabled) {\n    tsStartParseFunctionParams();\n  } else if (isFlowEnabled) {\n    flowStartParseFunctionParams();\n  }\n\n  expect(tt.parenL);\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n  parseBindingList(\n    tt.parenR,\n    false /* isBlockScope */,\n    false /* allowEmpty */,\n    allowModifiers,\n    funcContextId,\n  );\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseClass(isStatement, optionalId = false) {\n  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later\n  // code can easily navigate to meaningful points on the class.\n  const contextId = getNextContextId();\n\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  state.tokens[state.tokens.length - 1].isExpression = !isStatement;\n  // Like with functions, we declare a special \"name scope\" from the start of the name to the end\n  // of the class, but only with expression-style classes, to represent the fact that the name is\n  // available to the body of the class but not an outer declaration.\n  let nameScopeStartTokenIndex = null;\n  if (!isStatement) {\n    nameScopeStartTokenIndex = state.tokens.length;\n    state.scopeDepth++;\n  }\n  parseClassId(isStatement, optionalId);\n  parseClassSuper();\n  const openBraceIndex = state.tokens.length;\n  parseClassBody(contextId);\n  if (state.error) {\n    return;\n  }\n  state.tokens[openBraceIndex].contextId = contextId;\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  if (nameScopeStartTokenIndex !== null) {\n    const endTokenIndex = state.tokens.length;\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, false));\n    state.scopeDepth--;\n  }\n}\n\nfunction isClassProperty() {\n  return match(tt.eq) || match(tt.semi) || match(tt.braceR) || match(tt.bang) || match(tt.colon);\n}\n\nfunction isClassMethod() {\n  return match(tt.parenL) || match(tt.lessThan);\n}\n\nfunction parseClassBody(classContextId) {\n  expect(tt.braceL);\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (eat(tt.semi)) {\n      continue;\n    }\n\n    if (match(tt.at)) {\n      parseDecorator();\n      continue;\n    }\n    const memberStart = state.start;\n    parseClassMember(memberStart, classContextId);\n  }\n}\n\nfunction parseClassMember(memberStart, classContextId) {\n  if (isTypeScriptEnabled) {\n    tsParseModifiers([\n      ContextualKeyword._declare,\n      ContextualKeyword._public,\n      ContextualKeyword._protected,\n      ContextualKeyword._private,\n      ContextualKeyword._override,\n    ]);\n  }\n  let isStatic = false;\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._static) {\n    parseIdentifier(); // eats 'static'\n    if (isClassMethod()) {\n      parseClassMethod(memberStart, /* isConstructor */ false);\n      return;\n    } else if (isClassProperty()) {\n      parseClassProperty();\n      return;\n    }\n    // otherwise something static\n    state.tokens[state.tokens.length - 1].type = tt._static;\n    isStatic = true;\n\n    if (match(tt.braceL)) {\n      // This is a static block. Mark the word \"static\" with the class context ID for class element\n      // detection and parse as a regular block.\n      state.tokens[state.tokens.length - 1].contextId = classContextId;\n      parseBlock();\n      return;\n    }\n  }\n\n  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);\n}\n\nfunction parseClassMemberWithIsStatic(\n  memberStart,\n  isStatic,\n  classContextId,\n) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseClassMemberWithIsStatic(isStatic)) {\n      return;\n    }\n  }\n  if (eat(tt.star)) {\n    // a generator\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n    return;\n  }\n\n  // Get the identifier name so we can tell if it's actually a keyword like \"async\", \"get\", or\n  // \"set\".\n  parseClassPropertyName(classContextId);\n  let isConstructor = false;\n  const token = state.tokens[state.tokens.length - 1];\n  // We allow \"constructor\" as either an identifier or a string.\n  if (token.contextualKeyword === ContextualKeyword._constructor) {\n    isConstructor = true;\n  }\n  parsePostMemberNameModifiers();\n\n  if (isClassMethod()) {\n    parseClassMethod(memberStart, isConstructor);\n  } else if (isClassProperty()) {\n    parseClassProperty();\n  } else if (token.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {\n    state.tokens[state.tokens.length - 1].type = tt._async;\n    // an async method\n    const isGenerator = match(tt.star);\n    if (isGenerator) {\n      next();\n    }\n\n    // The so-called parsed name would have been \"async\": get the real name.\n    parseClassPropertyName(classContextId);\n    parsePostMemberNameModifiers();\n    parseClassMethod(memberStart, false /* isConstructor */);\n  } else if (\n    (token.contextualKeyword === ContextualKeyword._get ||\n      token.contextualKeyword === ContextualKeyword._set) &&\n    !(isLineTerminator() && match(tt.star))\n  ) {\n    if (token.contextualKeyword === ContextualKeyword._get) {\n      state.tokens[state.tokens.length - 1].type = tt._get;\n    } else {\n      state.tokens[state.tokens.length - 1].type = tt._set;\n    }\n    // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n    // a getter or setter\n    // The so-called parsed name would have been \"get/set\": get the real name.\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n  } else if (token.contextualKeyword === ContextualKeyword._accessor && !isLineTerminator()) {\n    parseClassPropertyName(classContextId);\n    parseClassProperty();\n  } else if (isLineTerminator()) {\n    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n    parseClassProperty();\n  } else {\n    unexpected();\n  }\n}\n\nfunction parseClassMethod(functionStart, isConstructor) {\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n  parseMethod(functionStart, isConstructor);\n}\n\n// Return the name of the class property, if it is a simple identifier.\nexport function parseClassPropertyName(classContextId) {\n  parsePropertyName(classContextId);\n}\n\nexport function parsePostMemberNameModifiers() {\n  if (isTypeScriptEnabled) {\n    const oldIsType = pushTypeContext(0);\n    eat(tt.question);\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function parseClassProperty() {\n  if (isTypeScriptEnabled) {\n    eatTypeToken(tt.bang);\n    tsTryParseTypeAnnotation();\n  } else if (isFlowEnabled) {\n    if (match(tt.colon)) {\n      flowParseTypeAnnotation();\n    }\n  }\n\n  if (match(tt.eq)) {\n    const equalsTokenIndex = state.tokens.length;\n    next();\n    parseMaybeAssign();\n    state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;\n  }\n  semicolon();\n}\n\nfunction parseClassId(isStatement, optionalId = false) {\n  if (\n    isTypeScriptEnabled &&\n    (!isStatement || optionalId) &&\n    isContextual(ContextualKeyword._implements)\n  ) {\n    return;\n  }\n\n  if (match(tt.name)) {\n    parseBindingIdentifier(true);\n  }\n\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n}\n\n// Returns true if there was a superclass.\nfunction parseClassSuper() {\n  let hasSuper = false;\n  if (eat(tt._extends)) {\n    parseExprSubscripts();\n    hasSuper = true;\n  } else {\n    hasSuper = false;\n  }\n  if (isTypeScriptEnabled) {\n    tsAfterParseClassSuper(hasSuper);\n  } else if (isFlowEnabled) {\n    flowAfterParseClassSuper(hasSuper);\n  }\n}\n\n// Parses module export declaration.\n\nexport function parseExport() {\n  const exportIndex = state.tokens.length - 1;\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExport()) {\n      return;\n    }\n  }\n  // export * from '...'\n  if (shouldParseExportStar()) {\n    parseExportStar();\n  } else if (isExportDefaultSpecifier()) {\n    // export default from\n    parseIdentifier();\n    if (match(tt.comma) && lookaheadType() === tt.star) {\n      expect(tt.comma);\n      expect(tt.star);\n      expectContextual(ContextualKeyword._as);\n      parseIdentifier();\n    } else {\n      parseExportSpecifiersMaybe();\n    }\n    parseExportFrom();\n  } else if (eat(tt._default)) {\n    // export default ...\n    parseExportDefaultExpression();\n  } else if (shouldParseExportDeclaration()) {\n    parseExportDeclaration();\n  } else {\n    // export { x, y as z } [from '...']\n    parseExportSpecifiers();\n    parseExportFrom();\n  }\n  state.tokens[exportIndex].rhsEndIndex = state.tokens.length;\n}\n\nfunction parseExportDefaultExpression() {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  if (isFlowEnabled) {\n    if (flowTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  const functionStart = state.start;\n  if (eat(tt._function)) {\n    parseFunction(functionStart, true, true);\n  } else if (isContextual(ContextualKeyword._async) && lookaheadType() === tt._function) {\n    // async function declaration\n    eatContextual(ContextualKeyword._async);\n    eat(tt._function);\n    parseFunction(functionStart, true, true);\n  } else if (match(tt._class)) {\n    parseClass(true, true);\n  } else if (match(tt.at)) {\n    parseDecorators();\n    parseClass(true, true);\n  } else {\n    parseMaybeAssign();\n    semicolon();\n  }\n}\n\nfunction parseExportDeclaration() {\n  if (isTypeScriptEnabled) {\n    tsParseExportDeclaration();\n  } else if (isFlowEnabled) {\n    flowParseExportDeclaration();\n  } else {\n    parseStatement(true);\n  }\n}\n\nfunction isExportDefaultSpecifier() {\n  if (isTypeScriptEnabled && tsIsDeclarationStart()) {\n    return false;\n  } else if (isFlowEnabled && flowShouldDisallowExportDefaultSpecifier()) {\n    return false;\n  }\n  if (match(tt.name)) {\n    return state.contextualKeyword !== ContextualKeyword._async;\n  }\n\n  if (!match(tt._default)) {\n    return false;\n  }\n\n  const _next = nextTokenStart();\n  const lookahead = lookaheadTypeAndKeyword();\n  const hasFrom =\n    lookahead.type === tt.name && lookahead.contextualKeyword === ContextualKeyword._from;\n  if (lookahead.type === tt.comma) {\n    return true;\n  }\n  // lookahead again when `export default from` is seen\n  if (hasFrom) {\n    const nextAfterFrom = input.charCodeAt(nextTokenStartSince(_next + 4));\n    return nextAfterFrom === charCodes.quotationMark || nextAfterFrom === charCodes.apostrophe;\n  }\n  return false;\n}\n\nfunction parseExportSpecifiersMaybe() {\n  if (eat(tt.comma)) {\n    parseExportSpecifiers();\n  }\n}\n\nexport function parseExportFrom() {\n  if (eatContextual(ContextualKeyword._from)) {\n    parseExprAtom();\n    maybeParseImportAssertions();\n  }\n  semicolon();\n}\n\nfunction shouldParseExportStar() {\n  if (isFlowEnabled) {\n    return flowShouldParseExportStar();\n  } else {\n    return match(tt.star);\n  }\n}\n\nfunction parseExportStar() {\n  if (isFlowEnabled) {\n    flowParseExportStar();\n  } else {\n    baseParseExportStar();\n  }\n}\n\nexport function baseParseExportStar() {\n  expect(tt.star);\n\n  if (isContextual(ContextualKeyword._as)) {\n    parseExportNamespace();\n  } else {\n    parseExportFrom();\n  }\n}\n\nfunction parseExportNamespace() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt._as;\n  parseIdentifier();\n  parseExportSpecifiersMaybe();\n  parseExportFrom();\n}\n\nfunction shouldParseExportDeclaration() {\n  return (\n    (isTypeScriptEnabled && tsIsDeclarationStart()) ||\n    (isFlowEnabled && flowShouldParseExportDeclaration()) ||\n    state.type === tt._var ||\n    state.type === tt._const ||\n    state.type === tt._let ||\n    state.type === tt._function ||\n    state.type === tt._class ||\n    isContextual(ContextualKeyword._async) ||\n    match(tt.at)\n  );\n}\n\n// Parses a comma-separated list of module exports.\nexport function parseExportSpecifiers() {\n  let first = true;\n\n  // export { x, y as z } [from '...']\n  expect(tt.braceL);\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n    parseExportSpecifier();\n  }\n}\n\nfunction parseExportSpecifier() {\n  if (isTypeScriptEnabled) {\n    tsParseExportSpecifier();\n    return;\n  }\n  parseIdentifier();\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n  if (eatContextual(ContextualKeyword._as)) {\n    parseIdentifier();\n  }\n}\n\n/**\n * Starting at the `module` token in an import, determine if it was truly an\n * import reflection token or just looks like one.\n *\n * Returns true for:\n * import module foo from \"foo\";\n * import module from from \"foo\";\n *\n * Returns false for:\n * import module from \"foo\";\n * import module, {bar} from \"foo\";\n */\nfunction isImportReflection() {\n  const snapshot = state.snapshot();\n  expectContextual(ContextualKeyword._module);\n  if (eatContextual(ContextualKeyword._from)) {\n    if (isContextual(ContextualKeyword._from)) {\n      state.restoreFromSnapshot(snapshot);\n      return true;\n    } else {\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (match(tt.comma)) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  } else {\n    state.restoreFromSnapshot(snapshot);\n    return true;\n  }\n}\n\n/**\n * Eat the \"module\" token from the import reflection proposal.\n * https://github.com/tc39/proposal-import-reflection\n */\nfunction parseMaybeImportReflection() {\n  // isImportReflection does snapshot/restore, so only run it if we see the word\n  // \"module\".\n  if (isContextual(ContextualKeyword._module) && isImportReflection()) {\n    next();\n  }\n}\n\n// Parses import declaration.\n\nexport function parseImport() {\n  if (isTypeScriptEnabled && match(tt.name) && lookaheadType() === tt.eq) {\n    tsParseImportEqualsDeclaration();\n    return;\n  }\n  if (isTypeScriptEnabled && isContextual(ContextualKeyword._type)) {\n    const lookahead = lookaheadTypeAndKeyword();\n    if (lookahead.type === tt.name && lookahead.contextualKeyword !== ContextualKeyword._from) {\n      // One of these `import type` cases:\n      // import type T = require('T');\n      // import type A from 'A';\n      expectContextual(ContextualKeyword._type);\n      if (lookaheadType() === tt.eq) {\n        tsParseImportEqualsDeclaration();\n        return;\n      }\n      // If this is an `import type...from` statement, then we already ate the\n      // type token, so proceed to the regular import parser.\n    } else if (lookahead.type === tt.star || lookahead.type === tt.braceL) {\n      // One of these `import type` cases, in which case we can eat the type token\n      // and proceed as normal:\n      // import type * as A from 'A';\n      // import type {a} from 'A';\n      expectContextual(ContextualKeyword._type);\n    }\n    // Otherwise, we are importing the name \"type\".\n  }\n\n  // import '...'\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseMaybeImportReflection();\n    parseImportSpecifiers();\n    expectContextual(ContextualKeyword._from);\n    parseExprAtom();\n  }\n  maybeParseImportAssertions();\n  semicolon();\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction shouldParseDefaultImport() {\n  return match(tt.name);\n}\n\nfunction parseImportSpecifierLocal() {\n  parseImportedIdentifier();\n}\n\n// Parses a comma-separated list of module imports.\nfunction parseImportSpecifiers() {\n  if (isFlowEnabled) {\n    flowStartParseImportSpecifiers();\n  }\n\n  let first = true;\n  if (shouldParseDefaultImport()) {\n    // import defaultObj, { x, y as z } from '...'\n    parseImportSpecifierLocal();\n\n    if (!eat(tt.comma)) return;\n  }\n\n  if (match(tt.star)) {\n    next();\n    expectContextual(ContextualKeyword._as);\n\n    parseImportSpecifierLocal();\n\n    return;\n  }\n\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      // Detect an attempt to deep destructure\n      if (eat(tt.colon)) {\n        unexpected(\n          \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n        );\n      }\n\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    parseImportSpecifier();\n  }\n}\n\nfunction parseImportSpecifier() {\n  if (isTypeScriptEnabled) {\n    tsParseImportSpecifier();\n    return;\n  }\n  if (isFlowEnabled) {\n    flowParseImportSpecifier();\n    return;\n  }\n  parseImportedIdentifier();\n  if (isContextual(ContextualKeyword._as)) {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportAccess;\n    next();\n    parseImportedIdentifier();\n  }\n}\n\n/**\n * Parse import assertions like `assert {type: \"json\"}`.\n *\n * Import assertions technically have their own syntax, but are always parseable\n * as a plain JS object, so just do that for simplicity.\n */\nfunction maybeParseImportAssertions() {\n  if (isContextual(ContextualKeyword._assert) && !hasPrecedingLineBreak()) {\n    next();\n    parseObj(false, false);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}